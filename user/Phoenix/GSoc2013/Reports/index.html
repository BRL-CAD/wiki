<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://brl-cad.github.io/wiki/user/Phoenix/GSoc2013/Reports/">
        <link rel="shortcut icon" href="../../../../img/favicon.ico">
        <title>Log - BRL-CAD Wiki</title>
        <link href="../../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../../..">BRL-CAD Wiki</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../../../.." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../../code/" class="nav-link">Code</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../../tasks/" class="nav-link">Tasks</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../../users/" class="nav-link">Users</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../../docs/" class="nav-link">Docs</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../../pdf/" class="nav-link">PDFs</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../../misc/" class="nav-link">Misc</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../../talks/" class="nav-link">Talks</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a href="https://github.com/BRL-CAD/wiki/blob/main/pages/user/Phoenix/GSoc2013/Reports.md" class="nav-link"><i class="fa fa-github"></i> Edit on GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#log" class="nav-link">Log</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#community-bonding" class="nav-link">Community bonding</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#week-1" class="nav-link">Week 1</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#week-2" class="nav-link">Week 2</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#week-3" class="nav-link">Week 3</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#week-4" class="nav-link">Week 4</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#week-5" class="nav-link">Week 5</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#week-6" class="nav-link">Week 6</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#week-7" class="nav-link">Week 7</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#mid-term-summary" class="nav-link">Mid-term summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#week-8" class="nav-link">Week 8</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#week-9" class="nav-link">Week 9</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#week-10" class="nav-link">Week 10</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#week-11" class="nav-link">Week 11</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#week-12" class="nav-link">Week 12</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#week-13" class="nav-link">Week 13</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#week-14" class="nav-link">Week 14</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#final-summary" class="nav-link">Final summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#test-results" class="nav-link">Test Results</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#original-development-timeline" class="nav-link">Original development timeline</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="log">Log</h1>
<h2 id="community-bonding">Community bonding</h2>
<ul>
<li>May 28<ul>
<li>Create the log page</li>
<li>Things have done:<ul>
<li>Test program for SSI and a test geometry file</li>
<li>Some improvement with SSI and API design</li>
</ul>
</li>
</ul>
</li>
<li>June 3<ul>
<li>As I will have my final exams during the first week that coding
    begins, so I'd like to move some work ahead.</li>
<li>Begin to add P/P, P/C and P/S support. Implement ON_PX_EVENT
    for reporting the intersections.</li>
<li>TODO: Implement P/C, P/S and ON_PX_EVENT::IsValid().</li>
</ul>
</li>
<li>June 4<ul>
<li>Eliminate max_dis in the brep command for SSI.</li>
<li>Extended the brep command to handle P/P, P/C, P/S, C/C and C/S.</li>
<li>Modified the wiki page of the brep command.</li>
<li>Fix the format of ON_PX_EVENT::Dump(). (Add "\n")</li>
</ul>
</li>
<li>June 7<ul>
<li>Try to add PS support using get_closest_point().</li>
<li>Test the functionality of the PS function - it seems that
    there's a problem when try (0,0,5) on a sphere of radius 5 and
    centered at the origin (it should be an intersect, but
    get_closest_point() returns (0,0,-5) resulting in no
    intersections).</li>
</ul>
</li>
<li>June 12<ul>
<li>Calculate point-curve intersection using sub-division.</li>
<li>Do some simple testing on PCI. It works.</li>
</ul>
</li>
</ul>
<h2 id="week-1">Week 1</h2>
<ul>
<li>June 17<ul>
<li>Coding period begins!</li>
<li>Put the tolerance into consideration in the IsPointIn() test in
    PCI.</li>
<li>Write a test program on sphere to test P/P, P/C and P/S.<ul>
<li><s>It seems that get_closest_point() is not always robust.
    :( Maybe it's not a good choice for P/S.</s></li>
</ul>
</li>
</ul>
</li>
<li>June 18<ul>
<li>Use macros to represent default tolerance and change it to 0.001
    (the same as the default tolerance of curve/curve,
    curve/surface, surface/surface defined by openNURBS)</li>
<li>Consider the input u_domain and v_domain for the result of
    point-surface intersection.</li>
</ul>
</li>
<li>June 19<ul>
<li>Busy with the course projects and preparing a final exam. Didn't
    have much time for BRL-CAD.</li>
</ul>
</li>
<li>June 20<ul>
<li>Found the problem causing get_closest_point() to fail<ul>
<li>get_closest_point() sometimes give us the 'farthest'
    point.</li>
<li>=&gt; getClosestPointEstimate() didn't work.</li>
<li>=&gt; The surface tree are not built correctly.</li>
<li>=&gt; It seems that we inappropriately prepTrims when
    m_removeTrimmed is false, causing get_closest_point() to
    fail. Someone who wrote this code needs to check whether
    this change is correct.</li>
</ul>
</li>
<li>Use a smaller depth for PSI to improve performance.</li>
</ul>
</li>
<li>June 21<ul>
<li>Added Newton-Raphson iteration in PCI to improve accuracy (using
    the one from subdivision and linear approximation as a starting
    point)<ul>
<li>After test, it can work with tolerance set to
    ON_ZERO_TOLERANCE!</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="week-2">Week 2</h2>
<ul>
<li>June 24<ul>
<li>The plane was delayed for a long time. It took almost the whole
    day to get to Beijing. :(</li>
<li>Set removeTrimmed to false, otherwise the surface tree cannot be
    built correctly - since the last change raised a raytrace
    problem.</li>
</ul>
</li>
<li>June 25<ul>
<li>Began to implement curve-curve intersections.<ul>
<li>First using sub-division to find the intersecting bounding
    boxes.</li>
<li>Then use Newton-Raphson iterations to get an accurate
    result.</li>
<li>Finally check the validity of the solutions and check
    overlap.</li>
</ul>
</li>
<li>More tests and improvements are needed.</li>
<li>Added the new CCI and CSI functions to brep_debug.cpp.</li>
</ul>
</li>
<li>June 26<ul>
<li>Improvements and bug fixing of curve-curve intersection<ul>
<li>Add tolerance value in the bounding box intersections.</li>
<li>Check duplication before appending to the array x.</li>
<li>In the Newton-Raphson iterations, if the inverse fails, we
    try another two directions.</li>
<li>More work on the tolerance value to get a more accurate and
    correct result.</li>
</ul>
</li>
<li>Add a test program for curve-curve intersections.</li>
</ul>
</li>
<li>June 27<ul>
<li>Continued improving curve-curve intersection<ul>
<li>Merge the overlap events that are continuous.</li>
<li>Eliminate the intersection points that are inside the
    overlap events.</li>
<li>Some special handling for linear curves.</li>
</ul>
</li>
<li>Add another test for overlaps.</li>
</ul>
</li>
<li>June 28<ul>
<li>More work on CCI<ul>
<li>Assign values to m_a[1], m_A[1], etc. even if it's
    ccx_point event (according to openNURBS declarations in
    other/openNURBS/opennurbs_x.h)</li>
<li>Fixed the wrong curve used in detecting overlaps.</li>
</ul>
</li>
<li>Added more comments to document the intersection approaches.</li>
<li>Studied materials on curve-surface intersections and ready to
    get started.</li>
</ul>
</li>
</ul>
<h2 id="week-3">Week 3</h2>
<ul>
<li>July 1<ul>
<li>Began to implement curve-surface intersections<ul>
<li>Use sub-division and Newton-Raphson iterations.</li>
<li>It's similar to curve-curve intersections.</li>
</ul>
</li>
</ul>
</li>
<li>July 2<ul>
<li>Added tests for curve-surface intersections.</li>
<li>Improved curve-surface intersections<ul>
<li>Check the endpoints of the line segment when computing its
    intersection with a boundary plane.</li>
<li>Consider NaN.</li>
<li>Add fabs() when calculating the line_t.</li>
</ul>
</li>
<li>Fixed a typo in brep.c ("CS" for curve-surface rather than
    "PC").</li>
</ul>
</li>
<li>July 3<ul>
<li>Added another test for CSI (line &amp; torus).</li>
<li>Continued improving curve-surface intersections.<ul>
<li>Reused surface tree - avoid generating the surface tree
    again and again.</li>
<li>Added some special splitting machanism for polylines.</li>
<li>Comparing doubles cannot use minus directly.</li>
<li>If the starting point is good enough, we don't need Newton
    iterations.</li>
<li>When merging, m_b should be consistent with m_a.</li>
<li>Values of 3D and 2D spaces should have different tolerances.
    And consider the 2D tolerance when merging.</li>
</ul>
</li>
</ul>
</li>
<li>July 4<ul>
<li>Started to work on surface-surface intersections (TDD)<ul>
<li>Did some clean up to the original code.</li>
<li>Split the two steps (intersecting bounding boxes and
    triangular approximation).</li>
<li>Dealt with single points, and checked validity of the
    solutions.</li>
</ul>
</li>
<li>Using tests (csgbrep.g): brep sph.brep intersect tor.brep 0 0</li>
</ul>
</li>
<li>July 5<ul>
<li>Improve SSI<ul>
<li>Dealt with surface boundaries (using CSI).</li>
<li>Some special handling for closed surfaces - added function
    closed_domain().</li>
<li>Eliminated duplicated points using a naive approach.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="week-4">Week 4</h2>
<ul>
<li>July 8<ul>
<li>Continued SSI<ul>
<li>Fixed bugs of triangle intersections - wrong line_normal
    for B, floating point issues (== is not sufficient),
    coincident planes cases, and calculate the barycentric
    coordination with ON_Solve2x2() in case that the inversion
    fails.</li>
<li>Calculate max_dis using the length of bounding box
    diagonal, in case that both volumes are zero.</li>
</ul>
</li>
<li>Modified brep_debug.cpp and test_ssi.cpp to deal with
    intersection points (use spheres to represent the points).</li>
</ul>
</li>
<li>July 9<ul>
<li>Uploaded some test images to this log with arb_intersect.g and
    csgbrep.g</li>
<li>Use 2D intersection tolerance with the 2D distances.</li>
<li>Linear fitting with the 2D intersection curves.</li>
</ul>
</li>
<li>July 10<ul>
<li>Perform Newton iterations to get more accurate surface-surface
    intersection points. (newton_ssi() in intersect.cpp)</li>
<li>Fixed a bug in triangle intersections raised by
    points_on_line.</li>
<li>More elegant SSI result display.</li>
<li>Did more tests and uploaded result images. (A problem comes out
    with the tests, as described below)</li>
</ul>
</li>
<li>July 11<ul>
<li>Worked on fitting the curves that SSI generates.<ul>
<li>Used an independent function to work on curve fitting.</li>
<li>Added more fitting machanisms.</li>
<li>Arc fitting - use ON_Curve::IsArc(). But tests seems that
    it cannot work well. I'll figure out why this happens.</li>
<li>Ellipse fitting - ON_Curve::IsEllipse() cannot work because
    it only calls IsArc() in it. And it can not figure out when
    the curve is an elliptical arc. So I first wanted to use
    least square fitting provided by
    <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.83.7803">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.83.7803</a>,
    but found that openNURBS provided us with
    ON_GetConicEquationThrough6Points() and
    ON_IsConicEquationAnEllipse() which are very useful and
    decided to use them. The code works well, and these
    functions are also very helpful in other conic fittings
    (hyperbola, parabola).</li>
</ul>
</li>
</ul>
</li>
<li>July 12<ul>
<li>Fixed a bug of fitting<ul>
<li>The original code cannot deal with elliptical arcs that
    cross the point where t=0 - Duplicate the ellipse curve to
    make its domain [0, 4*pi].</li>
</ul>
</li>
<li>Tests and fixing the SSI code.<ul>
<li>Use a plane and an elliptic parabolic surface (epa). See the
    images below.</li>
<li>Use max_dis_u (v, s, t) seperately as the scale of their
    domains may differ a lot. Before this, the result is totally
    a mess, but after this it's much better.</li>
<li>Eliminate unnecessary collinear points on the polyline
    curves.</li>
<li>Remove the arc fitting code, because
    ON_PolylineCurve::IsArc() always returns false. The
    elliptical arc fitting code below will work for this.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="week-5">Week 5</h2>
<ul>
<li>July 15<ul>
<li>Normalized the intersection curves (use domain [0, 1]), and
    checked tangent events.</li>
<li>Checked domain parameters passed to ON_Intersect().</li>
<li>Used seaming curves to handle intersecting intersection curves.<ul>
<li>If two curves have points whose distance is less than
    max_dis (also consider the 2D distances), and they
    originally don't intersect (use curve-curve intersections),
    we generated a seaming curve to 'link' them together.
    Sometimes the seaming curves can be merged if they are
    continuous to one of the old curves.</li>
</ul>
</li>
</ul>
</li>
<li>July 16<ul>
<li>Read papers to get ideas to handle overlaps in surface-surface
    intersections.</li>
<li>Discusses with other developers on the mailing list.</li>
<li>Two approaches come to mind:<ul>
<li>If we assume the two surfaces are C-infinity, we can use the
    theorem 3 in paper
    <a href="http://libgen.org/scimag1/10.1016/S0010-4485%252896%252900099-1.pdf">http://libgen.org/scimag1/10.1016/S0010-4485%252896%252900099-1.pdf</a>
    (Thanks to Bryan Bishop). This can be reduced to several
    curve-surface overlap problems (already implemented) because
    the overlap region is bounded by surface boundaries.</li>
<li>Otherwise, we need to get points inside the overlap region
    (using surfA-&gt;NormalAt(u,v) and surfB-&gt;NormalAt(s,t)),
    and then find the boundary (merge the triangles using the
    points as vertexes). These approach doesn't require
    continuity, but is very slow (too many bounding boxes and
    intersection points) and may lack accuracy (we may not have
    points on the boundaries)</li>
</ul>
</li>
</ul>
</li>
<li>July 17<ul>
<li>Some slight modifications to SSI (Commit 56091)</li>
<li>Solved the under-determined system with Newton iterations using
    pseudo-inverse. (ON_Matrix::Invert()) can do this)</li>
<li>Began working on overlaps:<ul>
<li>Bezier patches satisfy the theorem 3 mentioned above. Since
    the Bezier patches for a NURBS surface are always bounded at
    the knots, we actually don't need to generate the Bezier
    patches explicitly, and we can get the boundaries of them
    using IsoCurve() on knots.</li>
<li>Get the 3D overlap boundary segments. (2D is working in
    process because CSI doesn't report a 2D curve on the
    surface)</li>
<li>Some tests and bug fixing.</li>
</ul>
</li>
</ul>
</li>
<li>July 18<ul>
<li>Generate a 2D curve on the surface for csx_overlap, so that we
    can have two 2D curves for ssx_overlap. (Debugged for a long
    time, because \~ON_CurveArray() will delete the curves)</li>
<li>Linked the curves together to form a loop. (Continued to discuss
    about solutions of overlap cases with Cliff)</li>
<li>Changed the direction of curves if necessary to satisfy the
    requirements of ON_SSX_EVENT. (For ssx_transverse events, the
    3d curve direction agrees with SurfaceNormalB x SurfaceNormalA.
    For ssx_tangent events, the orientation is random. For
    ssx_overlap events, the overlap region should be to the LEFT of
    that *m_curveA*.)</li>
</ul>
</li>
<li>July 19<ul>
<li>Read a paper provided by Cliff regarding sub-surface
    intersections using quasi-interpolating control net. But
    unfortunately it doesn't provide much help. Continued to discuss
    about solutions to surface-surface overlaps on the mailing list.</li>
<li>Recognized that there might be inner loops, so the original code
    only make sure that the left on the curve is the closed region,
    but not the overlap region if it's an inner loop. Used
    point-surface intersections to determined which side of the
    curve is actually the intersection.</li>
</ul>
</li>
</ul>
<h2 id="week-6">Week 6</h2>
<ul>
<li>July 22<ul>
<li>Eliminate the bounding boxes completely inside the overlap
    region, and intersection points inside the overlaps.</li>
<li>Determine inner loops and outer loops of the overlap region.</li>
<li>Pass trees to the point-surface intersections to avoid
    repeatedly generate the surface trees.</li>
<li>Test whether the overlap curve is an inner segment by testing
    whether the two sides of it are shared or not.</li>
</ul>
</li>
<li>July 23<ul>
<li>Posted my progress on the mailing list.</li>
<li>Coding part:<ul>
<li>Dealt with closed domains for the overlap curve segments.</li>
<li>Fixed the return values of ON_Intersect()s when x may not
    be empty initially.</li>
<li>Normalized the curves for ssx_overlap.</li>
<li>Some code clean up and added some comment to document the
    new features.</li>
</ul>
</li>
<li>Tested the overlaps and uploaded images to this log.</li>
</ul>
</li>
<li>July 24<ul>
<li>Handled degenerated cases (the curve is degenerated to a point)
    for C/C and C/S intersections.</li>
<li>Fixed two bugs of SSI<ul>
<li>A variable (knots) is deleted before where it's used.</li>
<li>Set the pointer to NULL after it's deleted otherwise Split()
    will failed if the pointer is passed in.</li>
</ul>
</li>
<li>Tested on the an extreme geometry provided by Cliff, and figured
    out what I should do next for the overlap case of SSI.</li>
</ul>
</li>
<li>July 25<ul>
<li>Fix a bug in linking overlap segments (the index should start
    from 0)</li>
<li>Use surface normals to help determine overlaps. The normals of
    the two surfaces should be parallel.</li>
<li>Modified the CSI sub-division routine. The sub-division should
    only stops when the curve is linear AND the surface is planar.
    Otherwise there might be problems with csx_overlap.</li>
<li>Continued to modify the surface-surface overlaps with the test
    case: extreme_ssi_test.g (added to source tree). The
    modification is not finished yet.</li>
</ul>
</li>
<li>July 26<ul>
<li>Improved SSI with the extreme test case.<ul>
<li>Used a struct to represent the overlap segments. Split the
    curves with the intersection points (with other curves), so
    that we can get closed regions.</li>
<li>Fixed a bug that cause sub_curve() to crash.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="week-7">Week 7</h2>
<ul>
<li>July 28<ul>
<li>Removed debug messages.</li>
<li>Uploaded test result (2D intersection curves) of
    extreme_ssi_test.g.</li>
<li>Still some work needed before we can have the final result.</li>
</ul>
</li>
<li>July 29<ul>
<li>Generating 2D overlapping curves in CSI used to have a wrong
    ordered point list. Fixed this by ignoring some inner points.</li>
<li>Removed the duplicated overlap curves.</li>
<li>There is something wrong with the screen of my laptop. So I sent
    it to repair. Hope I can get it back soon and continue to work.</li>
</ul>
</li>
<li>July 30<ul>
<li>Struggled to build up the environment using virtual machines on
    our school's computer since I cannot use my own laptop now.</li>
<li>Fixed the wrong logic of determining whether a bounding box (or
    a point) is inside an overlap region or not.</li>
</ul>
</li>
<li>July 31<ul>
<li>Discussed about r56303 on the mailing list.</li>
<li>Take the tolerance into consideration when deciding whether a
    box is inside the overlap region.</li>
<li>Delete the OverlapSegment when its curves are NULL.</li>
<li>Some code clean up<ul>
<li>Eliminate compiler warnings.</li>
<li>Avoid using dynamic memory allocation for the events.</li>
<li>Use build_curve_root() instead of duplicating that
    routine.</li>
<li>Use sub_curve() instead of repeating that routine.</li>
</ul>
</li>
</ul>
</li>
<li>Aug 1<ul>
<li>Testing "brep arb8.brep intersect ehy.brep 0 1 on csgbrep.g"
    failed. It seemed that J.invert() doesn't work. Used explicit
    pseudo-inverse.</li>
<li>Some code clean up.</li>
<li>Tried to implement PSI in a similar fashion of other
    intersections, so that further the surface tree structures can
    be easily reused during different intersections.</li>
</ul>
</li>
<li>Aug 2<ul>
<li>Reuse the surface trees and curve trees during multiple
    intersections to reduce repeat computation.</li>
<li>Tested the SSI and fixed several bugs:<ul>
<li>The tests on the overlap cases failed again. Tracked the
    changed since the last correct routine to find the problem.</li>
<li>Found several slight bugs and fixed them, and the result is
    correct now.</li>
<li>Committed the changes separately.</li>
</ul>
</li>
</ul>
</li>
<li>Aug 3<ul>
<li>More powerful handling for the direction of overlap curves. Try
    another two options if the mid point is not sufficient.</li>
<li>Upload the final result of the extreme case.</li>
</ul>
</li>
</ul>
<h2 id="mid-term-summary">Mid-term summary</h2>
<p>The week 7 is the mid-term evaluations. During the first half of GSoC, I
focused on the NURBS intersections, implemented P/P, P/C, P/S, C/C, C/S
intersections, and also made lots of improvements on the SSI implemented
last year, e.g. Newton iterations, overlap cases. Now according to the
schedule, we are going to the next half of GSoC next week, and I'll
start working on evaluating NURBS booleans.</p>
<p>A friendly remind of how to tests my results. If you want to have a
quick test on P/P, P/C and P/S, you can run
src/libbrep/test_point_intersect, or
src/libbrep/test_curve_intersect for C/C and C/S. If you want to test
SSI, you need to run librt/tests/test_ssi, but it doesn't have build-in
test cases, so you need to specify a .g file, and the objects in it.
Also, you can use the brep command in MGED, which can test all of these
six intersections.</p>
<h2 id="week-8">Week 8</h2>
<ul>
<li>Aug 5<ul>
<li>Start to work on evaluating NURBS booleans.<ul>
<li>Move the existing code in librt (written last summer) to
    libbrep, and use a separated file libbrep/boolean.c.</li>
<li>Fixed a small bug in the existing code (m_curveA =&gt;
    m_curveB)</li>
</ul>
</li>
<li>Help eliminate compiler warnings (and errors) in other files.</li>
</ul>
</li>
<li>Aug 6<ul>
<li>Make sub_curve() a global export function, and mark all other
    functions that should be only used within intersect.cpp with
    HIDDEN.</li>
<li>Revisited the code in libbrep/boolean.cpp, and lots of updates:<ul>
<li>Used ON_Curve rather than ON_NurbsCurve for better
    generality.</li>
<li>Eliminated the polyline curve assumption.</li>
</ul>
</li>
<li>Tests the existed boolean evaluations, and found problems that
    I'm going to fix. (brep arb8.brep u ehy.brep union for
    csgbrep.g)</li>
</ul>
</li>
<li>Aug 7<ul>
<li>Modified split_trimmed_face() in libbrep/boolean.cpp<ul>
<li>Fixed some bugs.</li>
<li>Used an enum to improve readablity of m_in_out.</li>
<li>Special handling for the first and last point.</li>
<li>Multiple inner loops (using std::vector)</li>
<li>Implemented IsPointInsideLoop() to help determine a curve is
    completely inside a loop or not.</li>
</ul>
</li>
<li>Fixed a bug in CCI<ul>
<li>The result after the Newton iterations might be nan.</li>
</ul>
</li>
</ul>
</li>
<li>Aug 8<ul>
<li>Modified add_elements()<ul>
<li>Added vertexes correctly.</li>
<li>Use ON_Curve rather than ON_NurbsCurve to reduce
    unnecessary conversions.</li>
</ul>
</li>
<li>Fixed a bug in splitting surfaces - if the SSI event is not
    curves events, we don't need to do anything.</li>
<li>Found some cases that SSI curves may intersect, and the surface
    splitting routine only assumes that they are non-intersecting
    chains. Struggled to find a way to deal with this.</li>
</ul>
</li>
<li>Aug 9<ul>
<li>Fixed two bugs in split_trimmed_surface()<ul>
<li>Don't call Split() when t is on the boundary of domain.</li>
<li>The first point is not always on the first segment, so we
    might need to duplicate more than one segments.</li>
</ul>
</li>
<li>Linked the curves if they share an end point<ul>
<li>They can be from intersections with different surfaces</li>
<li>Or they are discontinuous in the other surface's domain, so
    not linked originally.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="week-9">Week 9</h2>
<ul>
<li>Aug 12<ul>
<li>Continued working on splitting trimmed faces.<ul>
<li>Implement a function to check the validity of the outer loop
    before adding a trimmed face.</li>
</ul>
</li>
<li>Some code clean up in libbrep/boolean.cpp.</li>
</ul>
</li>
<li>Aug 13<ul>
<li>Modified split_trimmed_face().<ul>
<li>Take care of the intersection tolerance, and "fix" the
    "gaps" if necessary.</li>
<li>Fixed bugs - NormalizedParameterAt() =&gt; ParameterAt();
    floating point comparisons.</li>
<li>Renamed a used macro (DEBUG =&gt; DEBUG_BREP_BOOLEAN)</li>
</ul>
</li>
</ul>
</li>
<li>Aug 14<ul>
<li>Used a better method to determine m_in_out - don't always
    assume that the starting point is outside, but use
    IsPointInsideLoop() to check around that point to determine it's
    going inside or outside.</li>
<li>Some other minor modifications - move link_curves() to
    ON_Boolean(), and ignore ssx_overlap curves when partitioning
    the face.</li>
</ul>
</li>
<li>Aug 15<ul>
<li>Tried improving surface partitioning<ul>
<li>Handled the case when an SSI curve overlaps with the outer
    loop.</li>
<li>Implemented get_subcurve_inside_faces().</li>
<li>Ignored UNSET IntersectPoints when maintaining the stack.</li>
</ul>
</li>
</ul>
</li>
<li>Aug 16<ul>
<li>Finished surface partitioning<ul>
<li>Eliminated the usage of sorted_pointers[] - once the
    array intersect[] is enlarged (with a new capacity), the
    pointers stored in sorted_pointers[] is no longer valid.</li>
<li>Tests, verification, and some minor changes.</li>
<li>Code clean up and added comment.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="week-10">Week 10</h2>
<ul>
<li>Aug 19<ul>
<li>Studied the paper about connectivity graphs.</li>
<li>Added basic support of connectivity graph. And built
    connectivity graphs for the original structure.<ul>
<li>Tests and fixed bugs.</li>
</ul>
</li>
</ul>
</li>
<li>Aug 20<ul>
<li>Struggled to find a way updating the connectivity graph after
    surface partitioning.<ul>
<li>More information about the edge sharing during the splitting
    procedure is needed.</li>
<li>Tried several ways but sucked, and finally came out an
    awkward implementation.</li>
</ul>
</li>
</ul>
</li>
<li>Aug 21<ul>
<li>Continued working on connectivity graphs<ul>
<li>Defined a macro to make the connectivity graph an optional
    choice.</li>
<li>Use an array of intervals to represent which part of the
    parent's outer loop that a TrimmedFace occupies.</li>
</ul>
</li>
</ul>
</li>
<li>Aug 22<ul>
<li>Code clean up - rename class members with "m_" prefix, use
    ON_ClassArray rather than "new" and "delete" operators.</li>
<li>Keep the information of the usage of SSI curve, so that we can
    know the connection between two trimmed faces (split from two
    surfaces), and get the connectivity graph of the new geometry
    after boolean evaluation.</li>
</ul>
</li>
<li>Aug 23<ul>
<li>Keep the original curve segments in LinkedCurve so that we can
    then share an edge with a neighboring face after we get the
    final evaluated structure.<ul>
<li>But this is still not enough. Maybe it should be postponed
    until we get to that stage, so that we can know actually
    what information are needed.</li>
</ul>
</li>
<li>Start to work on inside/outside tests<ul>
<li>Use curve-surface intersections to determine a point is
    inside a Brep or not.</li>
<li>Sean suggests using rt_brep_shot(). I'll look into that
    routine in brep.cpp (using for NURBS ray tracing) and find
    what can be reused.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="week-11">Week 11</h2>
<ul>
<li>Aug 25<ul>
<li>Looked into rt_brep_shot(). It needs to build the whole
    surface tree before we can process. I think it's not a good
    option for our inside/outside test. With CSI, deciding whether a
    point is inside a brep is quite easy.</li>
</ul>
</li>
<li>Aug 26<ul>
<li>Implemented IsFaceInsideBrep() to decide whether a trimmed face
    is inside another brep.<ul>
<li>Used randomly generated points.</li>
<li>Used it to decide whether the trimmed faces belong to the
    final structure according to type of the operation.</li>
</ul>
</li>
<li>Modified the brep command in MGED.</li>
</ul>
</li>
<li>Aug 27<ul>
<li>Flip the face if necessary (according to the operation and
    original face's bRev)</li>
<li>Made use of the connectivity graph to reduce inside/outside
    tests (if the USE_CONNECTIVITY_GRAPH flag is set).</li>
<li>Upload images to the wiki to show the result of NURBS boolean
    evaluations (intersection).</li>
</ul>
</li>
<li>Aug 28<ul>
<li>Tried to pass ON_Brep::IsValid().<ul>
<li>Added seaming trims, using the methods similar to the
    checking code in IsValid().</li>
<li>Dealt with singular trims and closed trims.</li>
<li>Solved trim &amp; vertex mismatch.</li>
</ul>
</li>
</ul>
</li>
<li>Aug 29<ul>
<li>Some code clean up.</li>
<li>Fixed wrong face direction.</li>
<li>Added another boolean operation - XOR.</li>
<li>Tested boolean evaluations and uploaded result images.</li>
</ul>
</li>
<li>Aug 30<ul>
<li>Began to implement comb -&gt; brep conversion, as the NURBS
    evaluations are ready now.<ul>
<li>Currently we need to pass the db_i* param all the way,
    because the comb tree only stores the names in the leaves,
    and we need the db to find the solid. Is there any more
    elegant way to deal with this?</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="week-12">Week 12</h2>
<ul>
<li>Sept 2<ul>
<li>Solve some invalid ON_Brep representations<ul>
<li>Avoid duplicated vertexes.</li>
<li>ISO type should be checked before we decide whether to share
    seam curves.</li>
</ul>
</li>
<li>Some code clean up.</li>
</ul>
</li>
<li>Sept 3<ul>
<li>Correctly reuse surface trees and curve trees.</li>
</ul>
</li>
<li>Sept 4<ul>
<li>Renamed some variables.<ul>
<li>db =&gt; dbip</li>
<li>brep_conversion =&gt; single_conversion</li>
</ul>
</li>
<li>Performed Xform on the leaves.</li>
<li>Checked 3D distance (not included in ON_Brep::IsValid()) when
    looking for seam trims.</li>
<li>Generated the connectivity graph for the new solid (after
    evaluation)</li>
<li>Discussions about db_i passing in rt_comb_brep().</li>
</ul>
</li>
<li>Sept 5<ul>
<li>Fixed wrong face direction of arbn =&gt; brep conversion<ul>
<li>The problem existed in rt_nmg_brep().</li>
</ul>
</li>
<li>Fixed a bug in trimmed face splitting<ul>
<li>Pointers may be invalid if the ON_SimpleArray's capacity is
    enlarged.</li>
</ul>
</li>
</ul>
</li>
<li>Sept 6<ul>
<li>Tests and fixed some bugs in libbrep/boolean.cpp<ul>
<li>get_subcurve_inside_face(): It should be the intersection
    of the two merged intervals, not union. And there might be
    no intersections (e.g. for an inner loop)</li>
<li>A slight bug: m_a =&gt; m_b (wrong param used)</li>
<li>Uploaded images to wiki.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="week-13">Week 13</h2>
<ul>
<li>Sept 9<ul>
<li>The school starts...</li>
<li>Improved the boolean evaluations<ul>
<li>Use the same surface if they are split from the same face.</li>
<li>Fix wrong vertex for the singular trims.</li>
<li>Detect whether the surfaces are the same - don't need SSI if
    they are the same.</li>
</ul>
</li>
</ul>
</li>
<li>Sept 10<ul>
<li>Surface equality checking<ul>
<li>Also checked their degree (order) and knots</li>
</ul>
</li>
<li>"Robustness Issues"<ul>
<li>Improve inside/outside tests for the cases with overlap
    surfaces.</li>
</ul>
</li>
</ul>
</li>
<li>Sept 11<ul>
<li>Some minor changes in libbrep/boolean.cpp</li>
<li>Installed and studied valgrind<ul>
<li>Fixed memory leaks in test_point_intersect and
    test_curve_intersect.</li>
</ul>
</li>
</ul>
</li>
<li>Sept 12<ul>
<li>Continued using valgrind to fix the memory leaks.<ul>
<li>boolean.cpp</li>
<li>SSI (intersect.cpp)</li>
</ul>
</li>
</ul>
</li>
<li>Sept 13<ul>
<li>Still fixing memory leaks.<ul>
<li>Face splitting.</li>
<li>Tree conversion.</li>
<li>Passed valgrind tests well after lots of efforts.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="week-14">Week 14</h2>
<ul>
<li>Sept 16<ul>
<li>Scheduled pencils down date...</li>
<li>Begin to do some code clean up and improve documentations<ul>
<li>Use rt_db_internal instead of ON_Brep for the interface
    between libged and librt.</li>
</ul>
</li>
</ul>
</li>
<li>Sept 17<ul>
<li>Added an "--no-evaluation" option, using the old routine of
    converting comb without NURBS evaluations (CSG tree + brep)</li>
<li>Scrub the code.</li>
</ul>
</li>
<li>Sept 18<ul>
<li>Scrub the code - src/libbrep/intersect.cpp<ul>
<li>Reused sub_curve() and sub_surface().</li>
<li>Added and corrected some comments.</li>
</ul>
</li>
</ul>
</li>
<li>Sept 19<ul>
<li>Rewrite the code of merging intervals in CCI and CSI<ul>
<li>Use only one pending interval.</li>
</ul>
</li>
<li>Corrected some comments.</li>
</ul>
</li>
<li>Sept 20<ul>
<li>Added more comment to the code, to make it more understandable.</li>
</ul>
</li>
</ul>
<h2 id="final-summary">Final summary</h2>
<ul>
<li>During GSoC '13, I implemented 6 independent intersection routines
    (point/point, point/curve, point/surface, curve/curve, curve/surface
    and surface/surface), tested and verified them, and they proved to
    be robust with the input I gave (even the extreme case). The most
    challenging task is the overlap cases in SSI (the result is 2D
    rather than 1D), which takes several weeks and hundreds lines of
    code.</li>
<li>After mid-term evaluation, I started to focus on NURBS boolean
    evaluations with the well-performed intersection routines. The main
    steps include splitting a trimmed face, inside/outside tests and
    forming the final b-rep structure. I'm pleased that I stayed on
    schedule during all these time, and finally finished a working NURBS
    evaluation routine and COMB conversion. Connectivity graphs take
    quite a lot of time to implement, and still not completed in some
    way (e.g. the information lost after the evaluation, because the
    edges are not shared), but it doesn't effect the performance a lot
    so finally we just disable this option. If it turns out to be useful
    later, we can enable it again, and do some modifications if needed.</li>
</ul>
<h1 id="test-results">Test Results</h1>
<ul>
<li>src/librt/tests/arb_intersect.g<ul>
<li>Intersection point: brep A_brep intersect B_brep 0 4 (The
    intersection point is marked with a sphere)<ul>
<li><img alt="" src="../../../img/Arb_point.png" /></li>
</ul>
</li>
<li>Intersection curve (a line segment): brep A_brep intersect
    B_brep 0 1 (The intersection line is marked as green and
    purple)<ul>
<li><img alt="" src="../../../img/Arb_line.png" /></li>
</ul>
</li>
</ul>
</li>
<li>csgbrep.g<ul>
<li>brep tor.brep intersect sph.brep 0 0<ul>
<li>2 intersection curves (2 circles)</li>
<li><img alt="" src="../../../img/Sph_tor.png" /></li>
<li>3D intersection curves (generated by test_ssi as pipe
    primitives)</li>
<li><img alt="" src="../../../img/Sph_tor_3d.png" /></li>
<li>2D intersection curves (generated by test_ssi as sketch
    primitives): as you can see, they are two line segments.</li>
<li><img alt="" src="../../../img/Sph_tor_2dA.png" />
    <img alt="" src="../../../img/Sph_tor_2dB.png" /></li>
</ul>
</li>
</ul>
</li>
<li>Intersection of two rcc's (They both have a bottom face that
    overlaps with each other, and the intersection curve of their side
    faces is a circle displayed in green.)<ul>
<li><img alt="" src="../../../img/Rcc_circle.png" /></li>
</ul>
</li>
<li>We translate and rotate the blue rcc, and intersect again its side
    face with the red one's side face, and get a 3D intersection curve.
    (Displayed in green)<ul>
<li><img alt="" src="../../../img/Rcc_3dcurve.png" /></li>
</ul>
</li>
<li>This time, their bottom are in the same plane, but only partly
    overlapped. The intersection of their side faces should be two
    points (If you look at the image below carefully, you can see a
    green point in the intersection).<ul>
<li><img alt="" src="../../../img/Rcc_point.png" /></li>
</ul>
</li>
<li>The below intersection has been described in paper
    <a href="http://www.sciencedirect.com/science/article/pii/0010448596000139">http://www.sciencedirect.com/science/article/pii/0010448596000139</a>.
    At a glance, the intersections look perfect (The left are 3D
    intersections and the right are 2D parametric ones.) But if you zoom
    the view, you can see some difference (The third image)<ul>
<li><img alt="" src="../../../img/Rcc_ortho_3d.png" />
    <img alt="" src="../../../img/Rcc_ortho_2d.png" />
    <img alt="" src="../../../img/Rcc_ortho_zoom.png" /></li>
<li><strong><em>This problem raised because the two intersection curves
    intersect with each other, but according to our fitting
    mechanism, one intersection point can only belong to ONE curve,
    and points can not be duplicated. So you can see that the two
    curves are actually separated when zoomed. How to solve this
    problem? I'm still struggling to find a solution. Hope anyone
    who see this log can share your ideas. :)</em></strong></li>
<li><strong><em>Some work on July 15 (using seaming segments) is to solve
    this problem.</em></strong></li>
</ul>
</li>
<li>An elliptic parabolic surface (epa side face) and a plane.<ul>
<li>The left image is the result before we use separate max_dis_u
    (v, s and t). The right image is the result after we fix this.
    The problem raises because the domain of the two parameters
    differ a lot (one is [0, 6.28] and the other is [0, 2000]).
    For example, two points (0, 0) and (6.28, 1) should not be
    neighbors, of course, but in the global scale majorly determined
    by the large domain [0, 2000], they become neighbors and the
    result is totally messy.</li>
<li><img alt="" src="../../../img/Epa_bad.png" />
    <img alt="" src="../../../img/Epa_good.png" /></li>
<li>The below are 2D parametric curves. The left is the projection
    on the plane surface (it's a parabola) and the right is the
    projection on the parabolic surface (it's some line segments).</li>
<li><img alt="" src="../../../img/Epa_2d_for_plane.png" />
    <img alt="" src="../../../img/Epa_2d_for_parabola.png" /></li>
</ul>
</li>
<li>Test ssx_overlap on planes (src/librt/tests/arb_intersect.g).<ul>
<li>brep A_brep intersect C_brep 0 1</li>
<li>Part of the two surfaces overlap.</li>
<li><img alt="" src="../../../img/Partial_overlap.png" /></li>
<li>brep A_brep intersect A_brep 0 0</li>
<li>We intersect two surfaces that are exactly the same. Maybe this
    case can be optimized (Detect it's a duplicated surface and
    return the boundary of the whole surface directly).</li>
<li><img alt="" src="../../../img/Completely_overlap.png" /></li>
</ul>
</li>
<li>The extreme test case (src/librt/tests/extreme_ssi_test.g):<ul>
<li>The 2D intersect curves generated as sketch primitives by
    test_ssi: test_ssi extreme_ssi_tests.g surface_1.s
    surface_2.s 0 0 (the 2D curves on surface A and those on
    surface B is the same). (New: the right one includes two
    intersection curves)</li>
<li><img alt="" src="../../../img/Five_rec.png" />
    <img alt="" src="../../../img/Extreme_final.png" /></li>
</ul>
</li>
<li>NURBS boolean evaluations (intersection)<ul>
<li>An arb8 and an ehy (left: original structures; right: result of
    intersection)</li>
<li><img alt="" src="../../../img/Arb8_ehy.png" />
    <img alt="" src="../../../img/Arb8_ehy_inter.png" /></li>
<li>A sph and a torus (left: original structures; right: result of
    intersection)</li>
<li><img alt="" src="../../../img/Ehy_tor.png" />
    <img alt="" src="../../../img/Ehy_tor_inter.png" /></li>
<li>Two spheres (first: result of union; second: result of
    intersection; third: result of difference)</li>
<li><img alt="" src="../../../img/Union_sph.png" />
    <img alt="" src="../../../img/Sph_sph_inter.png" />
    <img alt="" src="../../../img/Diff_sph.png" /></li>
<li>Two arb8 (first: union, second: intersection, third: diff)</li>
<li><img alt="" src="../../../img/Arb_union.png" />
    <img alt="" src="../../../img/Arb_intersect.png" />
    <img alt="" src="../../../img/Arb_diff.png" /></li>
</ul>
</li>
</ul>
<h1 id="original-development-timeline">Original development timeline</h1>
<ul>
<li>- June 17 (\~4 weeks)<ul>
<li>Study the papers on this topic</li>
<li>Discuss with other developers</li>
<li>Some code clean up in the current SSI routine</li>
<li>Write a test program to test SSI</li>
</ul>
</li>
<li>June 17 - June 23 (1 week)<ul>
<li>Lower dimension intersections<ul>
<li>P/P, P/C, P/S</li>
<li>With the support of openNURBS</li>
</ul>
</li>
<li>Tests and documentations</li>
</ul>
</li>
<li>June 24 - July 7 (2 weeks)<ul>
<li>Intersections regarding curves<ul>
<li>C/C, C/S</li>
<li>Subdivision - curve trees, surface trees</li>
</ul>
</li>
<li>Tests and documentations</li>
</ul>
</li>
<li>July 7 - Aug. 4 (4 weeks)<ul>
<li>TDD on SSI<ul>
<li>Test the SSI</li>
<li>Find the problems</li>
<li>Fix the bugs</li>
<li>Find more bugs and fix them</li>
<li>Degenerated cases</li>
</ul>
</li>
<li>Try to get the code faster<ul>
<li>Fit the curve to a lower order if possible</li>
</ul>
</li>
<li>Documentations<ul>
<li>Comment in code</li>
<li>Write some extra document on SSI (algorithms, problems,
    TODOs...)</li>
</ul>
</li>
<li>Mid-term evaluation in July 29 - Aug. 2</li>
</ul>
</li>
<li>Aug. 5 - Aug. 18 (2 weeks)<ul>
<li>Finish the surface partitioning<ul>
<li>Polygon partitioning</li>
<li>Curve-curve intersection</li>
</ul>
</li>
<li>Tests<ul>
<li>Trims may intersect</li>
</ul>
</li>
</ul>
</li>
<li>Aug. 19 - Aug. 25 (1 week)<ul>
<li>Add connectivity graph support<ul>
<li>Generate connectivity graphs for objects</li>
<li>Design proper data structures for the graph</li>
</ul>
</li>
</ul>
</li>
<li>Aug. 26 - Sept. 1 (1 week)<ul>
<li>Inside-outside tests<ul>
<li>Curve-surface intersection</li>
<li>BFS of the graph to determine inside/outside</li>
</ul>
</li>
</ul>
</li>
<li>Sept. 2 - Sept. 8 (1 week)<ul>
<li>Generate valid ON_Brep objects<ul>
<li>Read code in IsValid() functions</li>
<li>Add elements (trim, edge, etc.)</li>
<li>Try to pass the validation</li>
</ul>
</li>
<li>Extend the brep command in MGED</li>
</ul>
</li>
<li>Sept. 9 - Sept. 15<ul>
<li>Robustness Issues<ul>
<li>Deal with the degenerated cases</li>
<li>All 3 steps should be modified</li>
</ul>
</li>
<li>Tests<ul>
<li>Fix bugs</li>
<li>Improve performance</li>
</ul>
</li>
</ul>
</li>
<li>Sept. 16 - Sept. 22 (1 week)<ul>
<li>Pencils down<ul>
<li>Code clean up</li>
<li>Documentation (wiki pages)</li>
</ul>
</li>
</ul>
</li>
<li>Sept. 23 - Sept. 27 (1 week)<ul>
<li>Final evaluation</li>
<li>Submit code to Google</li>
</ul>
</li>
</ul></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../../js/base.js" defer></script>
        <script src="../../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
